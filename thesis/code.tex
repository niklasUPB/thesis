\section{Implementation}
In this section we provide a description of notable details of the implementation of our use-cases. 

\paragraph{Use Case One}
TODO
\begin{lstlisting}[caption={ The Python protocol of Conclave for our first use-case    }]
	def protocol():
	# define the schema for the input tables 
	columns_in_party1 = [
	defCol("primary_key", "INTEGER", [1]),
	defCol("user_data1_Alice", "INTEGER", [1]),
	defCol("user_data2_Alice", "INTEGER", [1]),
	defCol("user_data3_Alice", "INTEGER", [1]),
	]
	# the content of the tables is loaded from a pregenerated .csv
	input_1 = create("input_1", columns_in_party1, {1})
	
	columns_in_party2 = [
	defCol("primary_key", "INTEGER", [2]),
	defCol("user_data1_Bob", "INTEGER", [2]),
	defCol("user_data2_Bob", "INTEGER", [2]),
	defCol("user_data3_Bob", "INTEGER", [2])
	]
	input_2 = create("input_2", columns_in_party2, {2})
	# calculate the join over the two tables 
	join_result = join(input_1, input_2, 'join_result', ['primary_key'], ['primary_key'])
	# reveal the output of the join to Alice
	collect(join_result, 1)
	# reveal the output of the join  to Bob
	collect(join_result, 2)
	
	if __name__ == "__main__":
	with open(sys.argv[1], "r") as config:
	# load the configuration data
	config = json.load(config)
	# tell Conclave to generate secure code for the protocol an execute it
	workflow.run(protocol, c, mpc_framework="jiff", apply_optimisations=True)
\end{lstlisting}
\begin{lstlisting}[caption={Simpifiyed Protocol for our first use-case in ABY3}]
	
	std::vector<ColumnInfo> AliceCols = { ColumnInfo{ "key", TypeID::IntID, keyBitCount } };
	std::vector<ColumnInfo> BobCols = { ColumnInfo{ "key", TypeID::IntID, keyBitCount } };
	
	for (u32 i = 1; i < cols; ++i)
	{
		AliceCols.emplace_back("Alice" + std::to_string(i), TypeID::IntID, 32);
		BobCols.emplace_back("Bob" + std::to_string(i), TypeID::IntID, 32);
	}
	# Create tables for Alice and Bob and fill them with content
	Table AliceTable(rows, AliceCols);
	Table BobTable(rows, BobCols);
	# Fill the primary columns 
	for (u64 i = 0; i < rows; ++i)
	{
		# if out is false then the entry will be included in the join
		auto out = (i >= intersectionsize);
		for (u64 j = 0; j < 2; ++j)
		{
			AliceTable.mColumns[0].mData(i, j) = i + 1;
			BobTable.mColumns[0].mData(i, j) = i + 1 + (rows * out);
		}
	}
	# Fill the other columns with random integers
	for (u64 i = 1;  i < cols; ++i){
		for (u64 j =0; j < rows; ++j){
			AliceTable.mColumns[i].mData(j, 0) = rand() ;
			BobTable.mColumns[i].mData(j, 0) = rand();	
		}
	}
	# instanciate Timer for benchmarking
	Timer t;
	# Alice and Bob each run their own thread 
	auto routine = [&](int i) { setThreadName("t0");
		t.setTimePoint("start");
		# 
		auto A = (i == 0) ? srvs[i].localInput(AliceTable) : srvs[i].remoteInput(0);
		auto B = (i == 0) ? srvs[i].localInput(BobTable) : srvs[i].remoteInput(0);
		
		if (i == 0) t.setTimePoint("inputs");
		if (i == 0) srvs[i].setTimer(t);
		std::vector<SharedTable::ColRef>  First_Select_collumns;		
		for (u64 i = 0;  i < cols; ++i){
			First_Select_collumns.emplace_back(SharedTable::ColRef(B,B.mColumns[i]) );
		}
		for (u64 i = 1;  i < cols; ++i){
			First_Select_collumns.emplace_back(SharedTable::ColRef(A,A.mColumns[i]) );
		}
		auto result =srvs[i].join( SharedTable::ColRef(A,A.mColumns[0]) , SharedTable::ColRef(B,B.mColumns[0]), First_Select_collumns);
		if (i == 0) t.setTimePoint("intersect");
		for (u64 index = 0; index < result.mColumns.size(); ++index)
		{
			aby3::i64Matrix reveal(result.mColumns[index].rows(),  result.mColumns[index].i64Cols());
			server[i].mEnc.revealAll(server[i].mRt.mComm, T.mColumns[index], reveal);
			if (i == 0) std:: cout << reveal << std::endl;	
		}
	};
	
	auto t0 = std::thread(routine, 0);
	auto t1 = std::thread(routine, 1);
	t0.join();
	t1.join();
}
\end{lstlisting}
\paragraph{Use-Case Two}
For our second use-case we do not implement the query directly. Instead we implement another query that has an identical output. To obtain the desired result Alice and Bob compute two  intermediate results, the union of these intermediate results will then yield our final result, an equivalent SQL statement is listened \hyperref[use_case2_alternative_sql]{ in Listing 6.5}.
In a first step Alice and Bob filter their input once so that it contains only entries with the value false in its boolean column. Afterwards they can compute the join of these two filtered tables. The Result of this join is the first important intermediate result, as each of its entries is also part of the final result. The second important intermediate result can be obtained the by the same procedure when filtering the input for entries that contain true.
The union of these two intermediate results is our final result. 

We have chosen to implement the use-case in this indirect way for two reasons. First Conclave cannot evaluate the query directly, as Conclave's current prototype implementation can apply a WHERE filter exclusivity to a table that is either direct input of a party, or the output of unary operator, that has only one table as input. Additionally our indirect implementation has a significant better performance compared to the direct implementation, for a detail analysis see   \hyperref[evaluation]{ Evaluation}.  


\phantomsection
\label{use_case2_alternative_sql}
\begin{lstlisting}[caption={  Functional equivalent SQL statement for our implementation of use-case two }]
SELECT PimaryKey, AliceBool, BobBool FROM
(SELECT PrimaryKey, AliceBool FROM AliceTable WHERE AliceBool == false) 
NATURAL JOIN	
(SELECT PrimaryKey, BobBool FROM AliceTable WHERE BobBool == false)	
UNION
SELECT PimaryKey, AliceBool, BobBool FROM
(SELECT PrimaryKey, AliceBool FROM AliceTable WHERE AliceBool == true) 
NATURAL JOIN	
(SELECT PrimaryKey, BobBool FROM BobTable WHERE AliceBool == true)
\end{lstlisting}

\paragraph{Correctness}
Despite it not being obvious, our procedure indeed yields the correct result, as each join generates only entries, that have a primary key that is included in Bob's and Alice's inputs and have identical boolean values. Therefore every entry that is part of our result is also part of the correct result.

If any entry is not part of our result, it cannot be part of either intermediate result. Any entry that is not part of either intermediate result , feature a primary key that is either not represented in both inputs or contains two boolean values that are not equal.
Therefore the entry cannot be part of the correct result. Consequently each entry that is not part of our result, cannot be part of the correct result. Which is the contraposition and therefore equivalent, to the fact that each entry of the correct result is part of our result. 
As our result contains every entry of the correct result and the correct result contains every entry of our result, our result and the correct result are identical. Therefore our procedure is indent correct.



