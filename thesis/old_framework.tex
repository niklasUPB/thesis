\section{Discussion of Frameworks}
In this section we discuss important properties of the frameworks and compare them. 
At the end of the section we provide a \hyperref[Summary]{table} that summaries our discussion.
In their goals and general approach Conclave and SMCQL are very similar. Both Conclave and SMCQL employ an existing MPC frameworks in a new way, with the primary goal to make MPC more accessible. Conclave even describe SMCQL as ``the most similar state-of-the-art system'' \cite{10.1145/3302424.3303982}. ABY3 on the other hand, is new framework, that devolved new MPC protocols, with the primary goal to be as much efficient as possible. 
Conclave, ABY3 and SMCQL all assume a passive adversary that can corrupt at most one party. Therefore their security assumptions and guarantees are quite comparable. 
\paragraph{Features} 
When comparing the implemented features of the frameworks, there is no clear best framework. Since ABY3 focuses its efforts on joins, ABY3 provides the largest selection of join operations. In particular, ABY3 is the only framework that supports left and right joins. One category of features that ABY3 completely lacks are pre-implemented aggregate functions. Conclave and SMCQL both support sum aggregation. In addition, SMCQL is the only framework that supports pre-implemented maximums and count operators. Therefore SMCQL is the framework which supports the most aggregate functions. It is notable that the only two features that implemented in every frameworks are the Equi-join and UNION operators.  
\paragraph{Composability}
One notable aspect of each frameworks is their approach towards composability. Both Conclave and ABY3 lay huge emphasis on it and ensure all of their operators are composable. During our work with the frameworks this mechanism has saved us a lot of time and effort, because it significantly simplified the implementation of our more complex use cases.
SMCQL does not achieve full composability. On example where SMCQL fails to archive composability are select statements. As the majority of SMCQL's select statements cannot be subject to another select statement afterwards. During our work with SMCQL its limited composability has proven to impractical. 
\paragraph{Documentation}
It is not a trivial task to compare documentations objectively. There are hardly any measurable metrics that provide information about the quality of a documentation. However, one such metric is the amount of comments in the source code. We have found that SMCQL has the least amount of comments, in SMCQL there is about one comment for every 20 lines of code. ABY3 contains significantly more comments, the code of ABY3 contains one comment for every 10 lines of code. Conclave contains the most comments because Conclave contains one comment for every 5 lines of code. This measurement is consistent with the experience we have gained while working with the frameworks. In particular, we have observed Conclave's comments to be significantly more useful than those of ABY3. 

\paragraph{Experimental Software}
One shared property of ABY3, Conclave and SMCQL, is their implementations are experimental software that primarily serves a proof of concept. This manifest especially as the existence of numerous bugs and undesirable behaviour that are part of every framework. Conclave for example features a failure detector that is supposed, to detect, if a party crashed because of an  internal error and than abort the computation. This failure detector itself is extremely error-prone and tends to produce a significant amount of false positives, i.e. it aborts the execution of the protocol, despite no party actually being crashed. Such a false positive may for example be caused, by a party that is fully occupied with a computation and does not respond to messages of the failure detector in time. For some queries this problem is more significant then for others, in extreme cases we observed more then 50\% of all executions being aborted without justification. %Another example is SMCQL's exception handling. SMCQL  



Installing a secure multiparty computation framework and doing its install setup is often a complex and non-trivial task. To quote Hastings et al. ``Installing and running these systems can be challenging'' \cite{hastings2019sok} 
During our work we have observed this statement to be true for each of our candidates.
Especially for Conclave and SMCQL the instructions are often vague or incomplete. Conclave for example requires the installation of JIFF \cite{JIFF} a JavaScript library, as one of its dependencies. In order for JIFF to be usable for Conclave, one must actively chose to ignore several recommendations during its installation. The task is additionally complicated by the fact that, neither Conclave nor SMCQL provide sufficient test to locate errors in their setup precisely. For installing and doing its initial setup, ABY3 comes with a script that automates this task. In theory this approach simplifies the installation a lot. In practise the automated installation comes with its own issues. If, like in our case, such an installation does not function correctly, fixing its errors is a time consuming task, as it's lacks documentation and therefore it is a none trivial task to identify the root causes of it errors.


\begin{table}
	\phantomsection
	\label{Summary}	
	\centering
	\caption{Summary of important properties of the framework}
	\begin{tabular}{|l|l|l|l|} 
		\hline
		& ABY3                 & Conclave             & SMCQL                 \\ 
		\hline
		2 Parties            & No                   & Yes                  & Yes                   \\ 
		\hline
		3 Parties            & Yes                  & Yes                  & No                    \\ 
		\hline
		Passive Adversary    & Yes                  & Yes                  & Yes                   \\ 
		\hline
		Active~ Adversary    & No                   & No                   & No                    \\ 
		\hline
		Composable           & Yes                  & Yes                  & No                    \\ 
		\hline
		Quick Start Guide    & Yes                  & Yes                  & No                    \\ 
		\hline
		UNION Operator       & Yes                  & Yes                  & Yes                   \\ 
		\hline
		Equi-join            & Yes                  & Yes                  & Yes                   \\ 
		\hline
		Left Join            & Yes                  & No                   & No                    \\ 
		\hline
		Right Join           & Yes                  & No                   & No                    \\ 
		\hline
		Theta Join           & No                   & No                   & Yes                   \\ 
		\hline
		SUM aggregate        & No                   & Yes                  & Yes                   \\ 
		\hline
		MIN/MAX aggregate    & No                   & No                   & Yes                   \\ 
		\hline
		Projection           & No                   & Yes                  & Yes                   \\ 
		\hline
		Automated Setup           & Yes                   & No                  & No                   \\ 
		\hline
		
		\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} 
	\end{tabular}
\end{table}

\section{Rejected Frameworks}
\paragraph{CipherCompute}
On candidate for our study was CipherCompute \cite{Cosmian}. With the CypherCompute framework it is possible to solve a huge range of MPC problems using Rust. These include SQL operations like joins that are of interest for us. Furthermore CypherCompute provides a rich documentation, consisting of a full quickstart guide and several well documented example projects. CypherCompute utilises the SCALE-MAMBA \cite{aly2021scale} framework for its underlying MPC operations. SCALE-MAMBA  itself has evolved out of the well-known SPDZ \cite{SPDZ} protocol. Unfortunately the early access version of CypherCompute is out of maintenance by the time we conducting this study. Therefore we have decided to not include CypherCompute in our study.

\paragraph{Prio+}
Prio+ \cite{cryptoeprint:2021:576} is the next generation of the Prio \cite{201553} framework. Prio+ strives to maintain the same use and security as Prio, while significantly increasing performance compared to its predecessor. Prio Plus allows an arbitrary number of parties to jointly compute aggregated statistics, like SUM, MAX, MIN operators. Prio+ utilises a client server model. In which the (potentially many) input parties use a small number of servers to compute the statistics. Prio+ guarantees confidentiality of the input values if at least one server stays honest. Unlike CipherCompute or Conclave Prio+ is not a framework for developing MPC solutions. Its rather a system for special purposes. This means that the use of Prio+ can not be extended beyond the usecases that have been originally implemented by the authors of Prio+. This leaves Prio+ with a relatively small range of usecases compared to frameworks like ABY3 or Conclave. Therefore we have decided to not include Prio+ in our study.

\paragraph{VaultDB} 
VaultDB \cite{rogers2022vaultdb} is secure multiparty computation framework from 2022. VaultDB is secure in the presence of a passive adversary and supports two parties of which the adversary can corrupt at most one, therefore it resides in a setting with an honest majority. VaultDB is implemented on top of the EMP toolkit EMP toolkit \cite{emp-toolkit} which is an open source multiparty computation framework from 2016. VaultDB provides an open source implementation which demonstrates it's core capabilities.
A major shortcoming of VaultDB is the complete lack of documentation and as a result, a very low usability. Therefore it has been proven to be infeasible for us to implement any none trivial use case with it, within our time and resources. Consequently, it is not included in our study.

 