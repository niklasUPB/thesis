\chapter{Use-Cases}
In this chapter we describe the use-cases we have chosen to implement and benchmark. We first describe and motivate our choice of use-cases and, afterwards, give reasonable details on their implementation.
\section{Use-Case Description} 
We have decided to implement every use-case with Conclave and SMCQL for two parties. As ABY3 does not allow a two party protocol but requires at least three parties, we have implemented everything for ABY3 with three parties. For ABY3 there will always be only two parties that provide input data. The third party will not provide input data but will assist in the execution of the protocol. We will refer to first party that provides input as Alice and to the second party that provides input as Bob. 
\paragraph{Use-Case 1}
For our first use-case, we have chosen a single join. A single join may not be a very complex use-case but it is not irrelevant as joins are of great importance for practically every relational database query. It is estimated that over 60 \% of privacy-sensitive analytics queries include at least one join \cite{johnson2017practical}. In our first experiment, Alice and Bob each hold one table. Each of these tables consists of 4 columns. The first column serves as the primary key that is used for the join. The other 3 columns are filled with random non-negative integers and simulate user data. We are calculating an equijoin with the primary key generated in such a way that 50 \% of the entries in each table will match the join criteria. As result, we will reveal the entire outcome of the join. So the primary utility provided by the use of MPC operations is the fact that the entries that do not match the join criteria are obscured.

   \phantomsection
\label{SQL1_label}				
\begin{lstlisting}[caption={ Functional equivalent SQL statement for our first use-case  }]
SELECT * 
FROM Alice A JOIN Bob B 
ON  A.primary_key = B.primary_key
\end{lstlisting}
   \phantomsection
\label{SQL1}
			
\paragraph{Use-Case 2}
Computing joins alone is of limited use if the result of the join can not be subject to further selection. Therefore in our second use-case we will first compute a join and the query the result with a classic "SELECT ... FROM ... WHERE" statement. Similar to first experiment Alice and Bob again each hold one table. The tables consist of two columns. The first column serves as primary key and the second column contains a boolean values that is generated at random. For our experiment we will in a first step compute again compute the equijoin of the two tables with respect to the primary key column. In a second step we will apply a where filter to the result of the join and eliminate every row that does not have two identical boolean values. This use case functions also as a simple showcase example for composability and will show how well this mechanism functions in practise.   
\begin{lstlisting}[caption={Functional equivalent SQL statement for our second use-case}]
	SELECT * 
	FROM Alice A JOIN Bob B 
	ON  A.primary_key = B.primary_key
	WHERE  A.boolean = B.boolean 
\end{lstlisting}
\paragraph{Use-Case 3}
Besides joins, another very important group of SQL operations are aggregate functions. Over a third of all privacy-sensitive analytics queries requires a aggregation \cite{johnson2017practical}. Therefore our third use-case is centred around an aggregate function, or more precisely a maximum operator. 
%In our third experiment Alice and Bob each hold one table. The tables consist of two columns each. Like in our first and second use-case the first column will function as primary key and will be used for a join. The second column will be the column we aggregate over. In a first step we will be compute the join of the two columns  
 

\paragraph{Use-Case 4}
For our fourth and last use-case, we compare two special features of SMCQL and Conclave. Both Conclave and SMCQL feature a mechanic, that allows revealing some of the columns of the input data. The revelation of the input data allows them to apply optimizations that speed up computation while preserving the privacy of the other columns. For a more detailed description see \hyperref[Accesses_label]{SMCQL's access control} and \hyperref[Trust_label]{Conclave's trust annotations}. Therefore in our fourth use-case, we are going to replicate the setup of our first use-case but this time we will allow the leakage of the primary key column. That will allow both Conclave and SMCQL to apply their optimization. Replicating the setup of the first use-case enables us, to compare the results of the fourth use-case to the first use-case. This comparison will show how big the speed up of these optimizations is in practice. 
















