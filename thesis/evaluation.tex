\chapter{Evaluation}
In this chapter we discus the results of our benchmarks. We provide figures for the individual performance of the frameworks and highlight notable details. 
\paragraph{Experimental Setup}
All our benchmarks are conducted on a single machine that executes all parties. Our machine runs on a 64 bit Linux operations system, more precisely we use Debian 11 with the Linux Kernel version 5.10.0-18.amd64. The system features 4 CPUs that each run at 2,3 GHz and 128 GB of main space. In order to fit the results of different frameworks into shared figures, all our figures display runtime and space consumption in logarithmic scale to base e.    
\section{Use-Case One}
For our first evaluation we are inspecting the result of our first use-case in the localhost setting. For this first use-case we generalise that, Conclave scales better then SMCQL and ABY3 scales far better then Conclave. We have visualised a comparison of runtime , space consumption and generated network traffic in Listing 7.1 - 7.3.
\paragraph{Time}
For SMCQL we have been able to evaluate the query for up to 140 input rows. In order to compute the query with 140 input rows SMCQL took about 10 hours. For Conclave we have able to scale up to 500 input rows, with 500 row taking about 8 hours.
We have observed that the difference in speed between SMCQL and Conclave grows significantly larger with increasing input size. For an input of size 20, Conclave is 5 times faster then SMCQL, for an input of size 100 Conclave already is more then 50 times faster and for an input of size 140, Conclave is more then 75 times faster then SMCQL. In the first use-case ABY3 is by far the best scaling framework. ABY3 is able to compute the query with 140 and 500 input columns in less then a second. ABY3 runtimes does not increase in any significant way before its input reaches the mark of 128000 input rows, for which it requires 1.1 seconds or more precisely 1107 milliseconds. We have been able to evaluate the query with 16.000.000 input row in one minute and 46 seconds. 
\paragraph{Space}
Its notable that for large input sizes SMCQL is more space efficient then Conclave, while for small input input sizes Conclave is more space efficient then Conclave. They break even at by an input size of 60 rows, for which they both require about 870 MB of RAM. For input larger then 60 rows SMCQL scales significantly better then Conclave. For an input of size 140 rows SMCQL only needs about 1300MB while Conclave more then 4 times that much. As the space consumption of SMCQL grows in a very linear fashion and the space consumption of Conclave doubles in regular intervals, we can only assumes that this trend would continuo for large datasets. Similar to the case of the runtime, ABY3 hear also performs significantly better then Conclave and SMCQL. For input size 140, ABY3 only allocates 28MB of space and therefore is over 46 times more efficient then SMCQL. For input size 500, ABY3 allocates about 32 MB of space and is therefore 1800 times more efficient then Conclave, which requires over 58 GB of space.          
 
\label{evaluation}
%10 6:17
%20 25:02
%40 2:55:29
%50 23:05
%60 7:24:52
%40 3:07:24
%50 4:00
%70 7:38
%100 17:24.14
%150 53:23
%200 2:57:41
%250 6:58:13 6.90775527898214

\begin{tikzpicture}
	\begin{axis}[
	xmin = 0, xmax = 500,
	ymode=log,
	xtick distance = 50,
	log ticks with fixed point,
	x filter/.code=\pgfmathparse{#1 },
	grid = both,
	minor tick num = 1,
	major grid style = {lightgray},
	minor grid style = {lightgray!25},
	width = \textwidth,
	height = 0.5\textwidth,
	xlabel = { Size of Dataset },
	ylabel = { Runtime im seconds},
	legend style={at={(0.5,-0.1)},
	anchor=north,legend columns=-1}   ]	

\addplot[
color=blue!50!cyan,smooth,tension=0.7,very thick
] file[skip first] {conclave_use_case1_loca.dat};
\addlegendentry{Conclave}

%\addplot[color=blue!50!cyan,smooth,tension=0.7,very thick]file[skipfirst]{ABY_use_case1_local.dat};
\addplot[
color=orange!50!cyan,smooth,tension=0.7,very thick
] file[skip first] {SMCQL_use_case1_local.dat};
\addlegendentry{SMCQL}

\end{axis}

\end{tikzpicture}

%1466320 + 1419280 + 335772
%2300692 + 2470452 + 780664
%4344428 + 4358604 + 1217576
%9497772 + 9710384 + 2649820 
%14496916 + 16821556 + 6677548
%25940748 + 26352440 + 5739388

\section{Use-Case One}
For our second use-case we have described 

\begin{filecontents}{space_conclave_1.dat}
	0 0
	0 0
	100 3221372
	140 5551808
	200 9920608
	300 21857976
	400 37996020
	500 58032576
\end{filecontents}
\begin{filecontents}{space_SMCQL_1.dat}
	0 0
	0 0
	50 3221372
	70 5551808
	100 9920608
	150 21857976
	200 37996020
	250 58032576
\end{filecontents}



\begin{tikzpicture}
	\begin{axis}[
		xmin = 0, xmax = 500,
		ymode=log,
		xtick distance = 50,
		log ticks with fixed point,
		x filter/.code=\pgfmathparse{#1 },
		grid = both,
		minor tick num = 1,
		major grid style = {lightgray},
		minor grid style = {lightgray!25},
		width = \textwidth,
		height = 0.5\textwidth,
		xlabel = { Size of Dataset },
		ylabel = { Space consumption in kbytes},
		legend style={at={(0.5,-0.1)},
		anchor=north,legend columns=-1}]	
		
		\addplot[
		color=blue!50!cyan,smooth,tension=0.7,very thick
		] file[skip first] {space_conclave_1.dat};
		\addlegendentry{Conclave}
		\addplot[
		color=orange!50!cyan,smooth,tension=0.7,very thick
		] file[skip first] {space_SMCQL_1.dat};
		\addlegendentry{SMCQL}
	\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
	\begin{axis}[
		xmin = 0, xmax = 16224000,
		ymin = 0, ymax = 160,
		xtick distance = 2056000,
		ytick distance = 10,
		grid = both,
		minor tick num = 2,
		major grid style = {lightgray},
		minor grid style = {lightgray!25},
		width = \textwidth,
		height = 0.5\textwidth,
		xlabel = { Size of Dataset },
		ylabel = {Runtime im seconds },]	
		
		\addplot[
		color=blue!50!cyan,smooth,tension=0.7,very thick
		] file[skip first] {ABY_use_case2_local.dat};
		\addplot[
		color=blue!50!cyan,smooth,tension=0.7,very thick
		] file[skip first] {ABY_use_case2_fast_local.dat};
	\end{axis}
	
\end{tikzpicture}



